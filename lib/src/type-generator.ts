import { readdir } from 'node:fs/promises';
import { join, relative, basename, dirname, isAbsolute } from 'node:path';
import { writeFile, mkdir } from 'node:fs/promises';

export interface TypeGeneratorOptions {
  dataDir: string;
  projectRoot?: string; // Default: current working directory
}

interface TableInfo {
  tableName: string;
  schemaFile?: string;
}

export class TypeGenerator {
  private dataDir: string;
  private projectRoot: string;
  private outputFile: string;
  private dataDirPath: string;

  constructor(options: TypeGeneratorOptions) {
    // For testing: allow overriding projectRoot via environment variable
    const envProjectRoot = process.env.LINES_DB_TEST_PROJECT_ROOT;
    this.projectRoot =
      envProjectRoot !== undefined ? envProjectRoot : options.projectRoot || process.cwd();
    this.dataDir = options.dataDir;
    this.dataDirPath = isAbsolute(this.dataDir)
      ? this.dataDir
      : join(this.projectRoot, this.dataDir);
    this.outputFile = join(this.dataDirPath, 'db.ts');
  }

  /**
   * Generate types file from JSONL files and their optional schema files.
   */
  async generate(): Promise<string> {
    // Find all JSONL files and their corresponding schema files
    const tables = await this.findTables();

    if (tables.length === 0) {
      throw new Error(
        `No JSONL files found in ${this.dataDirPath}. Place one or more *.jsonl files in the directory.`,
      );
    }

    // Generate type declarations
    const content = this.generateTypeDeclarations(tables);

    // Ensure output directory exists
    const outputDir = dirname(this.outputFile);
    await mkdir(outputDir, { recursive: true });

    // Write to file
    await writeFile(this.outputFile, content, 'utf-8');
    console.log(`Generated types at ${this.outputFile}`);
    return this.outputFile;
  }

  /**
   * Find all *.jsonl files and check if they have corresponding *.schema.ts files
   */
  private async findTables(): Promise<TableInfo[]> {
    try {
      const entries = await readdir(this.dataDirPath, { withFileTypes: true });
      const tables: TableInfo[] = [];

      for (const entry of entries) {
        if (entry.isFile() && entry.name.endsWith('.jsonl')) {
          const tableName = basename(entry.name, '.jsonl');
          const schemaFileName = `${tableName}.schema.ts`;
          const schemaFilePath = join(this.dataDirPath, schemaFileName);

          // Check if schema file exists
          const hasSchema = entries.some((e) => e.isFile() && e.name === schemaFileName);

          tables.push({
            tableName,
            schemaFile: hasSchema ? schemaFilePath : undefined,
          });
        }
      }

      return tables;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        throw new Error(
          `Data directory not found: ${this.dataDirPath}. Set lines-db.dataDir to the correct location.`,
        );
      }
      throw error;
    }
  }

  /**
   * Generate type declaration content
   */
  private generateTypeDeclarations(tables: TableInfo[]): string {
    const imports: string[] = [];
    const tableEntries: string[] = [];
    const usedAliases = new Set<string>();

    for (const table of tables) {
      const tableKey = this.formatTableKey(table.tableName);

      if (table.schemaFile) {
        // Table has a schema file
        const schemaIdentifier = this.createSchemaIdentifier(table.tableName, usedAliases);
        usedAliases.add(schemaIdentifier);

        // Calculate relative path from output file to schema file
        let relativePath = relative(join(this.outputFile, '..'), table.schemaFile)
          .replace(/\\/g, '/') // Convert Windows paths to Unix-style
          .replace('.ts', '.js'); // Import from .js (TypeScript module resolution)

        // Ensure relative path starts with './' or '../'
        if (!relativePath.startsWith('.')) {
          relativePath = './' + relativePath;
        }

        // Add import statement for schema
        imports.push(`import { schema as ${schemaIdentifier} } from '${relativePath}';`);

        // Add table entry with InferOutput
        tableEntries.push(`  ${tableKey}: InferOutput<typeof ${schemaIdentifier}>;`);
      } else {
        // Table has no schema file, use Record<string, unknown>
        tableEntries.push(`  ${tableKey}: Record<string, unknown>;`);
      }
    }

    // Generate full content
    const importSection = imports.length > 0 ? `${imports.join('\n')}\n` : '';
    const inferOutputImport = imports.length > 0 ? ', InferOutput' : '';

    return `// Auto-generated by lines-db
// Do not edit this file manually

${importSection}import type { DatabaseConfig${inferOutputImport} } from '@toiroakr/lines-db';
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export type Tables = {
${tableEntries.join('\n')}
};

export const config: DatabaseConfig<Tables> = {
  dataDir: __dirname,
};
`;
  }

  private createSchemaIdentifier(tableName: string, usedAliases: Set<string>): string {
    const camel = toCamelCase(tableName);
    const sanitizedBase = sanitizeIdentifier(camel);
    let base = sanitizedBase || 'table';

    if (!/^[A-Za-z_$]/.test(base)) {
      base = `_${base}`;
    }

    let candidate = `${base}Schema`;
    let suffix = 1;
    while (usedAliases.has(candidate)) {
      candidate = `${base}${++suffix}Schema`;
    }

    return candidate;
  }

  private formatTableKey(tableName: string): string {
    const identifierPattern = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
    if (identifierPattern.test(tableName)) {
      return tableName;
    }
    const escaped = tableName.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    return `'${escaped}'`;
  }
}

function toCamelCase(value: string): string {
  const parts = value
    .split(/[^A-Za-z0-9]+/)
    .filter(Boolean)
    .map((part) => part.toLowerCase());

  if (parts.length === 0) {
    return value;
  }

  const [first, ...rest] = parts;
  return first + rest.map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join('');
}

function sanitizeIdentifier(value: string): string {
  return value.replace(/[^A-Za-z0-9_$]/g, '');
}
